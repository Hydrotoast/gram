package com.giocc.tensor

import java.util

/**
  * An N-dimensional point with n coordinates. We call the number of dimensions, N, the rank.
  */
sealed trait Subscript extends Iterator[Int] {

  /**
    * The number of dimensions of this subscript.
    */
  def rank: Int

  override def toString: String = mkString("(", ",", ")")

  override def equals(other: Any): Boolean = other match {
    case that: Subscript =>
      while (hasNext && that.hasNext) if (next != that.next) return false
      !hasNext && !that.hasNext
    case _ => false
  }

  override def hashCode(): Int = util.Arrays.hashCode(toArray)
}

/**
  * An N-dimensional point with n coordinates. We call the number of dimensions, N, the rank.
  *
  * @param _rank        The number of dimensions of the subscript.
  * @param _coordinates The array of coordinates for each of the the n dimensions. Must be non-empty.
  */
private[tensor] class IteratorSubscript(
  private val _rank: Int,
  private val _coordinates: Iterator[Int]
) extends Subscript {
  require(_rank > 0)

  override def rank: Int = _rank
  override def hasNext: Boolean = _coordinates.hasNext
  override def next(): Int = _coordinates.next()
}

/**
  * Iterates over the coordinates generated by this cartesian index assuming the given shape.
  *
  * @param _ind   The cartesian index.
  * @param _shape The shape.
  */
private[tensor] class LinearIndexSubscript(
  private var _ind: Int,
  _shape: Shape
) extends Subscript {
  private var _currentDimension = -1

  override def rank: Int = _shape.rank

  override def foreach[A](coordinateConsumer: Int => A): Unit = {
    var dimension = 0
    var ind = _ind
    while (dimension < rank) {
      val coordinate = ind % _shape(dimension)
      ind /= _shape(dimension)
      coordinateConsumer(coordinate)
      dimension += 1
    }
  }

  override def hasNext: Boolean = {
    _currentDimension < rank - 1
  }

  override def next(): Int = {
    if (!hasNext) {
      throw new IllegalStateException()
    }

    _currentDimension += 1
    val coordinate = _ind % _shape(_currentDimension)
    _ind /= _shape(_currentDimension)

    coordinate
  }
}

object Subscript {

  def of(coordinates: Int*): Subscript = {
    fromArray(coordinates.toArray)
  }

  def fromArray(coordinates: Array[Int]): Subscript = {
    fromIterator(coordinates.length, coordinates.iterator)
  }

  def fromIterator(rank: Int, coordinates: Iterator[Int]): Subscript = {
    new IteratorSubscript(rank, coordinates)
  }

  def fromLinearIndex(index: Int, shape: Shape): Subscript = {
    new LinearIndexSubscript(index, shape)
  }
}
