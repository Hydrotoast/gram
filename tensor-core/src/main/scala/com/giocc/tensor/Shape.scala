package com.giocc.tensor

import java.util

import com.giocc.tensor.iterator.{CoordinateIterator, SubscriptIterator}

/**
  * Represents the size of each dimension of an N-dimensional coordinate system. This data structure is immutable.
  *
  * @param _sizes The size of each dimension. Must be non-empty.
  */
class Shape(
  private val _sizes: Array[Int]
) {
  require(_sizes.nonEmpty)

  /**
    * Given a dimension, return the size of the dimension.
    *
    * @param dim The dimension.
    * @return The size of the dimension.
    */
  def apply(dim: Int): Int = _sizes(dim)

  /**
    * The number of dimensions.
    */
  def order: Int = _sizes.length

  /**
    * The product of the sizes of each dimension. Useful for allocating dense arrays. This operation is O(N).
    */
  def length: Int = {
    var result = 1
    _sizes.foreach {
      result *= _
    }
    result
  }

  /**
    * Constructs an array where each index represents a dimension and each element corresponds to the size of the given
    * dimension.
    */
  def toArray: Array[Int] = {
    _sizes.clone()
  }

  /**
    * An iterator over the valid subscripts within this shape.
    */
  def subscriptIterator: SubscriptIterator = {
    new SubscriptIterator(this)
  }

  /**
    * Given a cartesian index, constructs a coordinate iterator.
    *
    * @param ind The cartesian index.
    * @return A coordinate iterator.
    */
  def coordinateIteratorOf(ind: Int): CoordinateIterator = {
    new CartesianIndexIterator(this, ind)
  }

  override def equals(o: Any): Boolean = {
    o match {
      case that: Shape => _sizes.sameElements(that._sizes)
      case _ => false
    }
  }

  override def hashCode(): Int = {
    util.Arrays.hashCode(_sizes)
  }
}

/**
  * Iterates over the coordinates generated by this cartesian index assuming the given shape.
  *
  * @param _shape The shape.
  * @param _ind   The cartesian index.
  */
private class CartesianIndexIterator(
  _shape: Shape,
  _ind: Int
) extends CoordinateIterator {
  private var _currentDimension: Int = -1
  private var _currentInd = _ind

  override def hasNext: Boolean = {
    (_currentDimension + 1) < _shape.order
  }

  override def next(): Int = {
    if (!hasNext) {
      throw new IllegalStateException()
    }

    _currentDimension += 1
    val coordinate = _currentInd % _shape.apply(_currentDimension)
    _currentInd /= _shape.apply(_currentDimension)

    coordinate
  }
}

object Shape {
  def of(sizes: Int*): Shape = {
    new Shape(sizes.toArray)
  }
}