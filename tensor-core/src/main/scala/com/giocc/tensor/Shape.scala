package com.giocc.tensor

import java.util

/**
  * Represents the size of each dimension of an N-dimensional coordinate system. This data structure is immutable.
  *
  * @param _sizes The size of each dimension. Must be non-empty.
  */
class Shape(
  private val _sizes: Array[Int]
) {
  require(_sizes.nonEmpty)

  /**
    * Given a dimension, return the size of the dimension.
    *
    * @param dimension The dimension.
    * @return The size of the dimension.
    */
  def apply(dimension: Int): Int = _sizes(dimension)

  /**
    * The number of dimensions.
    */
  def order: Int = _sizes.length

  /**
    * The product of the sizes of each dimension. Useful for allocating dense arrays. This operation is O(N).
    */
  def length: Int = {
    var result = 1
    _sizes.foreach {
      result *= _
    }
    result
  }

  /**
    * Constructs an array where each index represents a dimension and each element corresponds to the size of the given
    * dimension.
    */
  def toArray: Array[Int] = {
    _sizes.clone()
  }

  /**
    * An iterator over the valid linear indices within this shape.
    */
  def linearIndexIterator: Iterator[Int] = {
    new LinearIndexIterator()
  }

  /**
    * An iterator over the valid subscripts within this shape.
    */
  def subscriptIterator: Iterator[Subscript] = {
    new SubscriptIterator()
  }

  /**
    * Given a cartesian index, constructs a coordinate iterator.
    *
    * @param ind The cartesian index.
    * @return A coordinate iterator.
    */
  def coordinateIteratorOf(ind: Int): CoordinateIterator = {
    new CartesianIndexIterator(ind)
  }

  override def equals(o: Any): Boolean = {
    o match {
      case that: Shape => _sizes.sameElements(that._sizes)
      case _ => false
    }
  }

  override def hashCode(): Int = {
    util.Arrays.hashCode(_sizes)
  }

  /**
    * Iterates over the coordinates generated by this cartesian index assuming the given shape.
    *
    * @param _ind The cartesian index.
    */
  private class CartesianIndexIterator(
    _ind: Int
  ) extends CoordinateIterator {
    private var _currentDimension: Int = -1
    private var _currentInd = _ind

    override def hasNext: Boolean = {
      (_currentDimension + 1) < Shape.this.order
    }

    override def next(): Int = {
      if (!hasNext) {
        throw new IllegalStateException()
      }

      _currentDimension += 1
      val coordinate = _currentInd % apply(_currentDimension)
      _currentInd /= apply(_currentDimension)

      coordinate
    }
  }

  /**
    * Iterates over the valid linear indices within the given shape.
    */
  private class LinearIndexIterator extends Iterator[Int] {
    private val _length: Int = Shape.this.length
    private var _item: Int = -1

    override def hasNext: Boolean = {
      _item < _length - 1
    }

    override def next(): Int = {
      if (!hasNext) {
        throw new IllegalStateException()
      }

      _item += 1
      _item
    }
  }

  /**
    * Iterates over the valid subscripts within the given shape.
    */
  private class SubscriptIterator extends Iterator[Subscript] {
    private val _length: Int = Shape.this.length
    private var _item: Int = 0
    private val _coordinates: Array[Int] = {
      val buffer = new Array[Int](order)
      buffer(0) = -1
      buffer
    }

    override def hasNext: Boolean = {
      _item < _length
    }

    override def next(): Subscript = {
      if (!hasNext) {
        throw new IllegalStateException()
      }

      updateCoordinates()
      _item += 1
      new Subscript(_coordinates)
    }

    private def updateCoordinates(): Unit = {
      // Find the first position where the coordinate has not reached its upper bound
      var i = 0
      while (i < _coordinates.length && _coordinates(i) == (apply(i) - 1)) {
        _coordinates(i) = 0
        i += 1
      }
      // Update the position if we have not reached the end of the coordinates
      if (i == _coordinates.length) {
        throw new IllegalStateException()
      } else { // _coordinates(i) != _shape(i)
        _coordinates(i) += 1
      }
    }
  }

}

object Shape {
  def of(sizes: Int*): Shape = {
    new Shape(sizes.toArray)
  }
}
